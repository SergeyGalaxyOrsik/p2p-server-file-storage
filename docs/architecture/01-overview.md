# Архитектура системы CourseStore

## 1. Общая архитектура

### 1.1. Концептуальная модель

CourseStore представляет собой гибридную P2P-систему распределённого хранения файлов, состоящую из трёх основных компонентов:

```
┌─────────────────┐
│  Metadata Server │  ← Центральный координатор
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
┌───▼───┐ ┌───▼───┐
│Client │ │Client │  ← Пользовательские клиенты
└───┬───┘ └───┬───┘
    │         │
    └────┬────┘
         │
    ┌────┴────┐
    │         │
┌───▼───┐ ┌───▼───┐
│ Node  │ │ Node  │  ← Узлы хранения
└───────┘ └───────┘
```

### 1.2. Компоненты системы

#### 1.2.1. Metadata Server (Сервер метаданных)
- **Назначение:** Центральный координатор системы
- **Роль:** Управление метаданными файлов, координация узлов хранения
- **Технологии:** C++, Winsock 2, WinAPI
- **Порт:** Конфигурируемый (по умолчанию 8080)

#### 1.2.2. Storage Node (Узел хранения)
- **Назначение:** Хранение фрагментов файлов (чанков)
- **Роль:** Предоставление дискового пространства для системы
- **Технологии:** C++, Winsock 2, WinAPI (CreateFile, ReadFile, WriteFile, GetDiskFreeSpaceEx)
- **Порт:** Динамический (регистрируется на сервере)

#### 1.2.3. Client (Клиент)
- **Назначение:** Интерфейс взаимодействия пользователя с системой
- **Роль:** Загрузка и скачивание файлов
- **Технологии:** C++, Winsock 2, WinAPI
- **Тип:** Консольное приложение

### 1.3. Принципы работы

1. **Разбиение файлов:** Файлы разбиваются на чанки фиксированного размера (1 МБ)
2. **Репликация:** Каждый чанк реплицируется на 2 различных узла (коэффициент репликации = 2)
3. **Распределение:** Чанки распределяются по доступным узлам с учётом их свободного места
4. **Отказоустойчивость:** При отказе одного узла файл остаётся доступным через реплику на другом узле

## 2. Потоки данных

### 2.1. Процесс загрузки файла

```
Client → Metadata Server: REQUEST_UPLOAD(filename, size)
Metadata Server → Client: UPLOAD_RESPONSE(node_list[])
Client → Node1: STORE_CHUNK(chunk_id, data)
Client → Node2: STORE_CHUNK(chunk_id, data)  [реплика]
...
Client → Metadata Server: UPLOAD_COMPLETE(filename, chunk_map)
```

### 2.2. Процесс скачивания файла

```
Client → Metadata Server: REQUEST_DOWNLOAD(filename)
Metadata Server → Client: DOWNLOAD_RESPONSE(chunk_map)
Client → Node1: GET_CHUNK(chunk_id)
Client → Node2: GET_CHUNK(chunk_id)  [параллельно]
...
Client: Сборка файла из чанков
```

### 2.3. Регистрация узла

```
Storage Node → Metadata Server: REGISTER_NODE(ip, port, free_space)
Metadata Server → Storage Node: REGISTER_RESPONSE(status, node_id)
Storage Node → Metadata Server: KEEP_ALIVE(node_id)  [периодически]
```

## 3. Структура проекта (монорепозиторий)

```
new-storage/
├── metadata-server/     # Проект сервера метаданных
│   ├── src/
│   ├── include/
│   └── CMakeLists.txt
├── storage-node/        # Проект узла хранения
│   ├── src/
│   ├── include/
│   └── CMakeLists.txt
├── client/              # Проект клиента
│   ├── src/
│   ├── include/
│   └── CMakeLists.txt
├── common/              # Общий код (протокол, утилиты)
│   ├── src/
│   ├── include/
│   └── CMakeLists.txt
├── docs/                # Документация
│   └── architecture/
├── CMakeLists.txt       # Корневой CMake
└── README.md
```

## 4. Технологический стек

- **Язык:** C++17 или новее
- **Сборка:** CMake
- **Сеть:** Winsock 2 (TCP/IP)
- **Системные API:** Windows API (WinAPI)
- **Платформа:** Windows 10/11, Windows Server 2016+

## 5. Ключевые архитектурные решения

### 5.1. Сетевое взаимодействие
- Использование TCP для надёжной доставки данных
- Текстовый протокол для простоты отладки (возможен переход на бинарный)
- Асинхронная обработка соединений на сервере

### 5.2. Хранение метаданных
- Хранение в оперативной памяти (для курсовой работы)
- Структура данных: `std::unordered_map` для быстрого доступа
- Опционально: сохранение состояния в JSON при завершении

### 5.3. Управление чанками
- Фиксированный размер чанка: 1 МБ (1048576 байт)
- Идентификация чанков: SHA-256 хеш содержимого
- Именование файлов чанков: `{chunk_id}.chunk`

### 5.4. Обработка ошибок
- Проверка доступности узлов через keep-alive
- Автоматическое удаление неактивных узлов
- Повторные попытки при сбоях передачи

